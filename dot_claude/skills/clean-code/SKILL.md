# クリーンコードスキル

このスキルは、クリーンコード原則、SOLID設計、ソフトウェアクラフトマンシップに関する専門知識を提供します。

## SOLID原則

### S - 単一責任の原則（SRP）
クラス/モジュールは変更する理由が1つだけであるべき。

```
悪い例: UserServiceが認証、プロフィール、通知を処理
良い例: AuthService, ProfileService, NotificationService
```

**違反の兆候:**
- クラスに無関係な複数のメソッドがある
- 一箇所の変更が無関係なコードの変更を必要とする
- 「と」や「または」なしでクラス名を付けるのが難しい

### O - オープン・クローズドの原則（OCP）
拡張に対して開いており、修正に対して閉じている。

```
悪い例: 支払い方法の追加にPaymentProcessorの修正が必要
良い例: PaymentProcessorはPaymentMethodインターフェースを使用し、新しい方法はそれを実装
```

**実装パターン:**
- Strategyパターン
- Template Methodパターン
- 依存性注入

### L - リスコフの置換原則（LSP）
サブタイプは基底タイプと置換可能でなければならない。

```
悪い例: SquareがRectangleを継承するがsetWidth/setHeightの動作を壊す
良い例: 両方がarea()メソッドを持つShapeインターフェースを実装
```

**違反の兆候:**
- サブクラスが親が投げない例外を投げる
- サブクラスが親の動作を無視する
- メソッド呼び出し前の型チェック

### I - インターフェース分離の原則（ISP）
クライアントは使用しないインターフェースに依存すべきでない。

```
悪い例: IWorkerインターフェースにwork(), eat(), sleep() - ロボットはeat/sleepしない
良い例: IWorkable, IFeedable, ISleepableインターフェース
```

**適用:**
- 小さく焦点を絞ったインターフェースを優先
- 役割ベースのインターフェース
- 「太った」インターフェースを避ける

### D - 依存性逆転の原則（DIP）
具象ではなく抽象に依存する。

```
悪い例: OrderServiceがMySQLDatabaseを直接インスタンス化
良い例: OrderServiceはIDatabaseに依存し、実行時に注入
```

**実装:**
- コンストラクタインジェクション
- インターフェースベースの設計
- IoCコンテナ

## クリーンコードの実践

### 命名

| ガイドライン | 悪い例 | 良い例 |
|-------------|--------|--------|
| 意図を明らかに | `d` | `elapsedTimeInDays` |
| 誤解を避ける | `accountList`（リストでない） | `accounts` |
| 発音可能 | `genymdhms` | `generationTimestamp` |
| 検索可能 | `7` | `MAX_RETRIES = 7` |
| エンコーディングを避ける | `strName`, `m_member` | `name`, `member` |

### 関数

**ルール:**
1. 小さく（理想は20行未満）
2. 1つのことだけを行う
3. 抽象度を1レベルに
4. わかりやすい名前
5. 引数は少なく（理想は0-2、最大3）
6. 副作用なし
7. コマンド/クエリの分離

```
悪い例:
function processUserData(user) {
  validate(user);
  save(user);
  sendEmail(user);
  updateMetrics();
  return user.id;
}

良い例:
function validateAndSaveUser(user) {
  validateUser(user);
  return saveUser(user);
}
// 関心事を別々の関数に分離
```

### コメント

**良いコメント:**
- 法的/ライセンス
- 意図の説明
- 難解なコードの明確化
- 結果の警告
- TODO（チケット参照付き）
- APIドキュメント

**悪いコメント:**
- 冗長（コードを言い換えているだけ）
- 誤解を招く
- 日誌/変更履歴
- ノイズコメント
- コメントアウトされたコード
- 位置マーカー

### エラーハンドリング

**原則:**
1. リターンコードではなく例外を使用
2. 例外にコンテキストを提供
3. 呼び出し側のニーズで例外クラスを定義
4. nullを返さない
5. nullを渡さない

```
悪い例:
if (employee != null) {
  if (employee.department != null) {
    return employee.department.name;
  }
}
return "Unknown";

良い例:
return employee?.department?.name ?? "Unknown";
// またはNull Objectパターンを使用
```

## コード構成

### ファイル構造
```
src/
├── domain/          # ビジネスロジック、エンティティ
├── application/     # ユースケース、サービス
├── infrastructure/  # 外部システム、DB
└── presentation/    # UI、APIコントローラー
```

### クラス構造
```
1. 定数
2. 静的フィールド
3. インスタンスフィールド
4. コンストラクタ
5. パブリックメソッド
6. プライベートメソッド（使用するパブリックメソッドの近くに）
```

## リファクタリング技法

### メソッドの抽出
コードが複数のことを行っているか、深いネストがある場合。

### 一時変数のクエリへの置換
一時変数が計算値に使用されている場合。

### パラメータオブジェクトの導入
複数のパラメータが一緒に移動する場合。

### 条件分岐のポリモーフィズムへの置換
型ベースの条件分岐が繰り返される場合。

### メソッドの構成
大きなメソッドを適切に名前付けされたステップに分解。

## コードスメル早見表

| スメル | 指標 | 解決策 |
|--------|------|--------|
| 長いメソッド | > 20行 | メソッドの抽出 |
| 大きなクラス | 複数の責任 | クラスの抽出 |
| 長いパラメータリスト | > 3パラメータ | パラメータオブジェクト |
| 重複コード | コピペ | メソッド/クラスの抽出 |
| 機能の横恋慕 | メソッドが他クラスのデータを使用 | メソッドの移動 |
| データの群れ | データ項目が頻繁に一緒に現れる | クラスの抽出 |
| プリミティブへの執着 | ドメイン概念にプリミティブ使用 | 値オブジェクト |
| switch文 | 型ベースの分岐 | ポリモーフィズム |
| 並行継承 | サブクラスが並行サブクラスを必要 | 階層の統合 |
| 怠惰なクラス | クラスがほとんど何もしない | クラスのインライン化 |
| 推測的な汎用性 | 未使用の抽象化 | 削除 |
| メッセージチェーン | a.b().c().d() | 委譲の隠蔽 |
| 中間者 | クラスが委譲するだけ | 中間者の除去 |
| 不適切な親密さ | クラス間の結合が強すぎる | 移動/抽出 |
| コメント | 悪いコードの説明 | コードをリファクタリング |

## テスト原則

### F.I.R.S.T.
- **Fast**: テストは高速に実行
- **Independent**: テストは互いに依存しない
- **Repeatable**: 毎回同じ結果
- **Self-Validating**: パスかフェイル、手動確認不要
- **Timely**: プロダクションコードの前/同時に書く

### テスト構造
```
Arrange: テスト条件を設定
Act: テスト対象コードを実行
Assert: 結果を検証
```

### 1テスト1アサート
各テストは1つの動作を検証。
